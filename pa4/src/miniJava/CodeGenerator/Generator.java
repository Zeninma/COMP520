package miniJava.CodeGenerator;

import miniJava.ErrorReporter;
import miniJava.AbstractSyntaxTrees.*;
import miniJava.AbstractSyntaxTrees.Package;
import miniJava.SyntacticAnalyzer.TokenKind;
import mJAM.*;
import mJAM.Machine.Op;
import mJAM.Machine.Prim;
import mJAM.Machine.Reg;
import java.util.HashMap;

/* Here is the NOTE
 * 
 * 1. Whenever refer to a method, no matte it has been visited or not
 * put it into this.patchMap,
 * Then before the end, do all the patches at one time.
 * 2. Use of Pop
 * 3. Error in the comment indicates there should be an error report
 * 4. Qutesion in the comment indicates there might be error,
 *  and if when it stops in the test, need to reconsider the corresponding part
 */

public class Generator implements Visitor<Object, Object> {
	public HashMap<Integer, Declaration> patchMap = new HashMap<Integer, Declaration>();
	public int mainCount = 0;
	public int patchAddr_Call_main;
	public int LBoffset = 0;
	public ErrorReporter errorReporter;
	public String fileName;

	public Generator(ErrorReporter reporter, String fileName) {
		this.errorReporter = reporter;
		this.fileName = fileName;
	}

	public enum Action {
		// put the result value on the top of the stack (can be an address)
		fetch,
		// put the address on the top of the stack
		assign;
	}

	public void checkMain(AST ast) {
		for (ClassDecl cd : ((Package) ast).classDeclList) {
			for (MethodDecl md : cd.methodDeclList) {
				this.isMain(md);
			}
		}
		if (this.mainCount == 0) {
			this.errorReporter.reportError("*** Generator Error occurs: Program has no valid main method");
			System.exit(4);
		} else if (this.mainCount > 1) {
			this.errorReporter.reportError("*** Generator Error occurs: Program has multiple main method");
			System.exit(4);
		} else {
			return;
		}
	}

	public void startGenerate(AST ast) {
		// start visiting the AST generated by
		// IdentificationVisitor, and making
		// generation.
		System.out.println("*********************** start Code Generation *************");
		this.checkMain(ast);
		Machine.initCodeGen();
		ast.visit(this, null);
		codePatch();

//		 // write the object file**************for submission
//		 String objectCodeFileName =this.fileName.replace(".java", ".mJAM");
//		 ObjectFile objF = new ObjectFile(objectCodeFileName);
//		 System.out.print("Writing object code file " + objectCodeFileName + "... ");
//		 if (objF.write()) {
//		 System.out.println("FAILED!");
//		 return;
//		 }
//		 else
//		 System.out.println("SUCCEEDED");
//		 // write the object file**************for submission

		/**************************************************************************/
		/**************************************************************************/
		/***************************** Debug ***********************************/
		/**************************************************************************/
		/**************************************************************************/
		/*
		 * write code to object code file (.mJAM)
		 */
		String objectCodeFileName = "test.mJAM";
		ObjectFile objF = new ObjectFile(objectCodeFileName);
		System.out.print("Writing object code file " + objectCodeFileName + " ... ");
		if (objF.write()) {
			System.out.println("FAILED!");
			return;
		} else
			System.out.println("SUCCEEDED");

		/****************************************************************************************
		 * The pa4 code generator should write an object file as shown above at
		 * the end of code generation and exit(0) if there are no errors.
		 * 
		 * During development of the code generator you may want to run the
		 * generated code directly after code generation using the mJAM debugger
		 * mode. You can adapt the following code for this (it assumes
		 * objectCodeFileName holds the name of the objectFile)
		 * 
		 */
		// create asm file using disassembler
		String asmCodeFileName = objectCodeFileName.replace(".mJAM", ".asm");
		System.out.print("Writing assembly file " + asmCodeFileName + " ... ");
		Disassembler d = new Disassembler(objectCodeFileName);
		if (d.disassemble()) {
			System.out.println("FAILED!");
			return;
		} else
			System.out.println("SUCCEEDED");

		/*
		 * run code using debugger
		 * 
		 */
		System.out.println("Running code in debugger ... ");
		Interpreter.debug(objectCodeFileName, asmCodeFileName);

		System.out.println("*** mJAM execution completed");
		/**************************************************************************/
		/**************************************************************************/
		/***************************** Debug ***********************************/
		/**************************************************************************/
		/**************************************************************************/
	}

	public void codePatch() {
		for (Integer key : this.patchMap.keySet()) {
			Machine.patch(key, this.patchMap.get(key).entity.methodAddr);
		}
	}

	@Override
	public Object visitPackage(Package prog, Object arg) {
		int staticFieldPtr = 0;
		// Begin Static Stack
		for (ClassDecl c : prog.classDeclList) {
			for (FieldDecl fd : c.fieldDeclList) {
				if (fd.isStatic) {
					Machine.emit(Op.PUSH, 1);
					fd.entity = new RunTimeEntity();
					staticFieldPtr++;
					fd.entity.staticFieldDis = staticFieldPtr;
					// push one
				}
			}
		}
		// Begin on Execution Stack
		this.patchAddr_Call_main = Machine.nextInstrAddr();
		Machine.emit(Op.CALL, Reg.CB, -1);
		Machine.emit(Op.POP, 0, 0, staticFieldPtr);
		Machine.emit(Op.HALT, 0, 0, 0);
		// Begin decorate Decls
		for (ClassDecl c : prog.classDeclList) {
			c.visit(this, false);
		}
		// After Class Decls' decoration
		for (ClassDecl c : prog.classDeclList) {
			c.visit(this, true);
		}
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/*****************************
	 * Visit Decl
	 ***********************************/

	/**************************************************************************/
	/**************************************************************************/

	@Override
	public Object visitClassDecl(ClassDecl cd, Object decorated) {
		if ((boolean) decorated) {
			// generate instructions for the class
			for (MethodDecl md : cd.methodDeclList) {
				md.visit(this, null);
			}
		} else {
			// decorate the class and the field
			cd.entity = new RunTimeEntity();
			cd.entity.size = 0;
			for (FieldDecl fd : cd.fieldDeclList) {
				if (!fd.isStatic) {
					fd.visit(this, cd.entity.size);
					// pass the distance to the OB
					cd.entity.size++;
				}
			}
		}
		return null;
	}

	@Override
	public Object visitFieldDecl(FieldDecl fd, Object distance) {
		// decorate the field decl, specify the distance from
		// Object's address
		if (!fd.isStatic) {
			fd.entity = new RunTimeEntity();
			fd.entity.fieldDis = (int) distance;
		}
		return null;
	}

	@Override
	public Object visitMethodDecl(MethodDecl md, Object notUsed) {
		md.entity = new RunTimeEntity();
		md.entity.methodAddr = Machine.nextInstrAddr();
		TypeKind returnType = md.type.typeKind;
		// patch main method address
		if (isMain(md)) {
			Machine.patch(this.patchAddr_Call_main, Machine.nextInstrAddr());
		}
		// Decorate Parameters' locations
		int pdNum = 0;
		for (ParameterDecl pd : md.parameterDeclList) {
			pdNum++;
			pd.visit(this, pdNum);
		}
		// start generate code for statement
		// set the LB offset to be 2
		this.LBoffset = 3;
		for (Statement stmt : md.statementList) {
			stmt.visit(this, pdNum);
		}
		// // return
		// if(returnType == TypeKind.VOID){
		// // No return element
		// Machine.emit(Machine.Op.RETURN, 0, 0, pdNum);
		// }
		// else{
		// // return 1 element, goes back to the previous address
		// // pops out k args
		// Machine.emit(Machine.Op.RETURN, 1, 0, pdNum);
		// }
		return null;
	}

	@Override
	public Object visitParameterDecl(ParameterDecl pd, Object offset) {
		// change
		pd.entity = new RunTimeEntity();
		pd.entity.LBoffset = -(int) offset;
		return null;
	}

	@Override
	public Object visitVarDecl(VarDecl decl, Object arg) {
		decl.entity = new RunTimeEntity();
		// set the Var Decl's LB offset
		decl.entity.LBoffset = this.LBoffset;
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/*****************************
	 * Visti Type
	 ***********************************/

	/**************************************************************************/
	/**************************************************************************/
	@Override
	public Object visitBaseType(BaseType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitClassType(ClassType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitArrayType(ArrayType type, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/**************************
	 * Visit Statement
	 *********************************/

	/**************************************************************************/
	/**************************************************************************/
	@Override
	public Object visitBlockStmt(BlockStmt stmt, Object arg) {
		// count the number of variables pushed
		int pushSpace = 0;
		for (Statement statement : stmt.sl) {
			if (statement instanceof VarDeclStmt) {
				pushSpace++;
			}
			statement.visit(this, null);
		}
		Machine.emit(Op.POP, 0, 0, pushSpace);
		this.LBoffset -= pushSpace;
		return null;
	}

	@Override
	public Object visitVardeclStmt(VarDeclStmt stmt, Object arg) {
		stmt.varDecl.visit(this, null);
		stmt.initExp.visit(this, Action.fetch);
		this.LBoffset++;
		return null;
	}

	@Override
	public Object visitAssignStmt(AssignStmt stmt, Object arg) {
		if (stmt.ref instanceof IdRef) {
			// id = Expr
			Declaration refDecl = stmt.ref.decl;
			if (refDecl instanceof VarDecl) {
				// on the stack
				// visit the expression,
				// the result is at the stack top
				stmt.val.visit(this, Action.fetch);
				// store the value to the Execution Stack
				Machine.emit(Op.STORE, Reg.LB, refDecl.entity.LBoffset);
			} else if (refDecl instanceof FieldDecl && ((FieldDecl) refDecl).isStatic) {
				// static field
				stmt.val.visit(this, Action.fetch);
				Machine.emit(Op.STORE, Reg.SB, refDecl.entity.staticFieldDis);
			} else {
				// non static field
				stmt.val.visit(this, Action.fetch);
				Machine.emit(Op.STORE, Reg.OB, refDecl.entity.fieldDis);
			}
		} else if (stmt.ref instanceof IxIdRef) {
			// Array is always an object
			// id[Expr] = Expr
			// array is always on the heap
			Declaration idDecl = stmt.ref.decl;
			// on the stack
			stmt.ref.visit(this, Action.assign);
			stmt.val.visit(this, Action.fetch);
			// take the object and the array index
			Machine.emit(Prim.arrayupd);
		} else if (stmt.ref instanceof ThisRef) {
			this.errorReporter.reportError("*** Generator Error occurs: Cannot assign 'this'");
			// Error, cannot assign this!
		} else if (stmt.ref instanceof QRef) {
			// id.field
			FieldDecl fd = (FieldDecl) ((QRef) stmt.ref).decl;
			if (fd.isStatic) {
				stmt.val.visit(this, Action.fetch);
				Machine.emit(Op.STORE, Reg.SB, fd.entity.staticFieldDis); // store
																			// into
																			// var
			} else {
				// Question, does fd has been decorated?
				stmt.ref.visit(this, Action.assign);
				stmt.val.visit(this, Action.fetch);
				Machine.emit(Prim.fieldupd);
			}
		} else {// IxQRef
			stmt.ref.visit(this, Action.assign);
			stmt.val.visit(this, Action.fetch);
			Machine.emit(Prim.arrayupd);
		}
		return null;
	}

	@Override
	public Object visitCallStmt(CallStmt stmt, Object arg) {
		for (Expression expr : stmt.argList) {
			// fill out the args on the list
			expr.visit(this, Action.fetch);
		}
		Reference currRef = stmt.methodRef;
		if (currRef instanceof IdRef) {
			// including this Ref
			MethodDecl idDecl = (MethodDecl) ((IdRef) currRef).decl;
			if (idDecl.isStatic) {
				this.patchMap.put(Machine.nextInstrAddr(), idDecl);
				Machine.emit(Op.CALL, Reg.CB, -1);
			} else {
				// load object address at the frame base
				Machine.emit(Op.LOAD, Reg.LB, 0);
				this.patchMap.put(Machine.nextInstrAddr(), idDecl);
				Machine.emit(Op.CALLI, Reg.CB, -1);
			}
			// delete return stmt
			int lastIdx = idDecl.statementList.size()-1;
			if(lastIdx>=0 && idDecl.statementList.get(lastIdx) instanceof ReturnStmt){
				Machine.emit(Op.POP,0,0,1);
			}
		} 
		else {
			// currRef instanceof QRef
			if (((QRef) currRef).id.spelling.equals("println")) {
				// for System.oyt.println()
				Machine.emit(Prim.putintnl);
			} else {
				currRef.visit(this, Action.fetch);
				this.patchMap.put(Machine.nextInstrAddr(), currRef.decl);
				Machine.emit(Op.CALLI, Reg.CB, -1);
			}
			MethodDecl md = (MethodDecl) currRef.decl;
			int lastIdx = md.statementList.size()-1;
			if(lastIdx>=0 && md.statementList.get(lastIdx) instanceof ReturnStmt){
				Machine.emit(Op.POP,0,0,1);
			}
		}
		return null;
	}

	@Override
	public Object visitReturnStmt(ReturnStmt stmt, Object parameterNum) {
		if (stmt.returnExpr != null) {
			stmt.returnExpr.visit(this, Action.fetch);
			Machine.emit(Op.RETURN, 1, 0, (int) parameterNum);
		} else {
			// return void
			Machine.emit(Op.RETURN, 0, 0, (int) parameterNum);
		}
		return null;
	}

	@Override
	public Object visitIfStmt(IfStmt stmt, Object arg) {
		stmt.cond.visit(this, Action.fetch);
		int ifAddr = Machine.nextInstrAddr();
		Machine.emit(Op.JUMPIF, 0, Reg.CB, -1);

		stmt.thenStmt.visit(this, null);
		int thenAddr = Machine.nextInstrAddr();
		Machine.emit(Op.JUMP, Reg.CB, -99);

		int elseAddr = Machine.nextInstrAddr();
		Machine.patch(ifAddr, elseAddr);
		// else stmt may not exist
		if (stmt.elseStmt != null) {
			stmt.elseStmt.visit(this, null);
		}
		int endAddr = Machine.nextInstrAddr();
		Machine.patch(thenAddr, endAddr);
		return null;
	}

	@Override
	public Object visitWhileStmt(WhileStmt stmt, Object arg) {
		int whileAddr = Machine.nextInstrAddr();
		stmt.cond.visit(this, Action.fetch);
		// Do or End?
		int whereAddr = Machine.nextInstrAddr();
		Machine.emit(Op.JUMPIF, 0, Reg.CB, -1);
		// Do
		stmt.body.visit(this, null);
		Machine.emit(Op.JUMP, Reg.CB, whileAddr);
		// End
		int endAddr = Machine.nextInstrAddr();
		Machine.patch(whereAddr, endAddr);
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/*****************************
	 * Visit Expr
	 ***********************************/

	/**************************************************************************/
	/**************************************************************************/

	/* For Variable Declaration needs to */
	@Override
	public Object visitUnaryExpr(UnaryExpr expr, Object arg) {
		// negate the value on the top of the stack
		expr.expr.visit(this, Action.fetch);
		switch (expr.operator.kind) {
		case MINUS:
			Machine.emit(Prim.neg);
			break;
		case NOT:
			Machine.emit(Op.LOADL, 0);
			Machine.emit(Prim.eq);
			break;
		default:
			break;
		}
		return null;
	}

	@Override
	public Object visitBinaryExpr(BinaryExpr expr, Object arg) {
	if (expr.operator.kind == TokenKind.AND){	
		expr.left.visit(this, Action.fetch);
		int firstJ = Machine.nextInstrAddr();
		Machine.emit(Op.JUMPIF, 0, Reg.CB, -1);// jump if the first one is false
		Machine.emit(Op.LOADL, 1);
		expr.right.visit(this, Action.fetch);
		Machine.emit(Prim.and);
		int endJ = Machine.nextInstrAddr();
		Machine.emit(Op.JUMP, Reg.CB,-1);
		Machine.patch(firstJ, Machine.nextInstrAddr());
		Machine.emit(Op.LOADL,0);
		Machine.patch(endJ, Machine.nextInstrAddr());
		return null;
	}
	else if (expr.operator.kind == TokenKind.OR){
		expr.left.visit(this, Action.fetch);
		int firstJ = Machine.nextInstrAddr();
		Machine.emit(Op.JUMPIF, 1, Reg.CB, -1); // jump if the first one is correct
		Machine.emit(Op.LOADL, 0);
		expr.right.visit(this, Action.fetch);
		Machine.emit(Prim.or);
		int endJ = Machine.nextInstrAddr();
		Machine.emit(Op.JUMP, Reg.CB,-1);
		Machine.patch(firstJ, Machine.nextInstrAddr());
		Machine.emit(Op.LOADL,1);
		Machine.patch(endJ, Machine.nextInstrAddr());
		return null;
	}
	else {
		expr.left.visit(this, Action.fetch);
		expr.right.visit(this, Action.fetch);
		switch(expr.operator.kind){
		case OR:
			Machine.emit(Prim.or);
			break;
		case AND:
			Machine.emit(Prim.and);
			break;
		case EQUAL:
			Machine.emit(Prim.eq);
			break;
		case NEQ:
			Machine.emit(Prim.ne);
			break;
		case LEQ:
			Machine.emit(Prim.le);
			break;
		case LT:
			Machine.emit(Prim.lt);
			break;
		case GT:
			Machine.emit(Prim.gt);
			break;
		case GEQ:
			Machine.emit(Prim.ge);
			break;
		case PLUS:
			Machine.emit(Prim.add);
			break;
		case MINUS:
			Machine.emit(Prim.sub);
			break;
		case TIMES:
			Machine.emit(Prim.mult);
			break;
		case DIVIDE:
			Machine.emit(Prim.div);
			break;
		default:
			break;
		}}
		return null;
	}

	@Override
	public Object visitRefExpr(RefExpr expr, Object arg) {
		// put the ref's result onto the stack
		expr.ref.visit(this, arg);
		return null;
	}

	@Override
	public Object visitCallExpr(CallExpr expr, Object arg) {
		// put the result value onto the stack
		for (Expression argExpr : expr.argList) {
			argExpr.visit(this, Action.fetch);
		}
		Reference funcRef = expr.functionRef;
		if (funcRef instanceof IdRef) {
			// including ThisRef
			// changed 15:48
			MethodDecl idDecl = (MethodDecl) ((IdRef) funcRef).id.decl;
			if (idDecl.isStatic) {
				// check builtin func
				this.patchMap.put(Machine.nextInstrAddr(), idDecl);
				Machine.emit(Op.CALL, Reg.CB, -1);
			} else {
				Machine.emit(Op.LOADA, Reg.OB, 0);
				this.patchMap.put(Machine.nextInstrAddr(), idDecl);
				Machine.emit(Op.CALLI, Reg.CB, -1);
			}
		} else {
			// funcRef instanceof QRef
			if ((((QRef) funcRef).id).spelling.equals("System")) {
				Machine.emit(Prim.putintnl);
			} else {
				funcRef.visit(this, Action.fetch);
				this.patchMap.put(Machine.nextInstrAddr(), ((QRef) funcRef).decl);
				Machine.emit(Op.CALLI, Reg.CB, -1);
			}
		}
		return null;
	}

	@Override
	public Object visitLiteralExpr(LiteralExpr expr, Object arg) {
		// put the result value onto the stack
		int val = 0;
		String spelling = expr.lit.spelling;
		switch (expr.lit.kind) {
		case NUM:
			val = Integer.parseInt(spelling);
			break;
		case TRUE:
			val = 1;
			break;
		case FALSE:
			val = 0;
			break;
		case NULL:
			val = 0;
			break;
		default:
			break;
		}
		Machine.emit(Op.LOADL, val);
		return null;
	}

	@Override
	public Object visitNewObjectExpr(NewObjectExpr expr, Object arg) {
		// put object address onto the stack
		int size = expr.classtype.className.decl.entity.size;
		Machine.emit(Op.LOADL, -1);
		Machine.emit(Op.LOADL, size);
		Machine.emit(Prim.newobj);
		return null;
	}

	@Override
	public Object visitNewArrayExpr(NewArrayExpr expr, Object arg) {
		expr.sizeExpr.visit(this, Action.fetch);
		Machine.emit(Prim.newarr);
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/******************************
	 * Visit Ref
	 ***********************************/

	/**************************************************************************/
	/**************************************************************************/
	@Override
	public Object visitThisRef(ThisRef ref, Object action) {
		Machine.emit(Op.LOADA, Reg.OB, 0);
		return null;
	}

	@Override
	public Object visitIdRef(IdRef ref, Object arg) {
		RunTimeEntity entity = ref.id.decl.entity;
		switch ((Action) arg) {
		case fetch:
			if (ref.id.decl instanceof FieldDecl) {
				if (((FieldDecl) ref.id.decl).isStatic) {
					// static field
					Machine.emit(Op.LOAD, Reg.SB, entity.staticFieldDis);
				} else {
					// non static
					Machine.emit(Op.LOAD, Reg.OB, entity.fieldDis);
				}
			} else {
				// local
				Machine.emit(Op.LOAD, Reg.LB, entity.LBoffset);
			}
			break;
		case assign:
			if (ref.id.decl instanceof FieldDecl) {
				if (((FieldDecl) ref.id.decl).isStatic) {
					// static field
					// return entity.staticFieldDis;
					Machine.emit(Op.LOADL, entity.staticFieldDis);
				} else {
					// non static
					// return entity.fieldDis;
					Machine.emit(Op.LOADL, entity.fieldDis);
				}
			} else {
				// local
				// return entity.LBoffset;
				Machine.emit(Op.LOADL, entity.LBoffset);
			}
		}
		return null;
	}

	@Override
	public Object visitIxIdRef(IxIdRef ref, Object arg) {
		switch ((Action) arg) {
		case fetch:
			// static and nonstatic
			Machine.emit(Op.LOAD, Reg.LB, ref.id.decl.entity.LBoffset);
			ref.indexExpr.visit(this, Action.fetch);
			Machine.emit(Prim.arrayref);
			break;
		case assign:
			Machine.emit(Op.LOAD, Reg.LB, ref.id.decl.entity.LBoffset);
			ref.indexExpr.visit(this, Action.fetch);
			break;
		}
		return null;
	}

	@Override
	public Object visitQRef(QRef ref, Object arg) {
		Declaration refDecl = ref.decl;
		switch ((Action) arg) {
		case fetch:
			if (refDecl instanceof FieldDecl) {
				if (((FieldDecl) refDecl).isStatic) {
					// static field
					Machine.emit(Op.LOAD, Reg.SB, refDecl.entity.staticFieldDis);
				} else {
					// non-static field
					// array.length
					if (ref.ref.decl.type instanceof ArrayType && ref.id.spelling.equals("length")) {
						ref.ref.visit(this, Action.fetch);
						Machine.emit(Prim.arraylen);
					} else {
						ref.ref.visit(this, Action.fetch);
						Machine.emit(Op.LOADL, refDecl.entity.fieldDis);
						Machine.emit(Prim.fieldref);
					}
				}
			} else {
				ref.ref.visit(this, Action.fetch);
			}
			break;
		case assign:
			if (((FieldDecl) refDecl).isStatic) {
				// static field
				return refDecl.entity.staticFieldDis;
			} else {
				if (ref.ref.decl.type instanceof ArrayType && ref.id.spelling.equals("length")) {
					this.errorReporter.reportError("*** Generator Error occurs: field length of array is read only");
				}
				// non-static field
				else {
					ref.ref.visit(this, Action.fetch);
					Machine.emit(Op.LOADL, refDecl.entity.fieldDis);
				}
			}
		}
		return null;
	}

	@Override
	public Object visitIxQRef(IxQRef ref, Object arg) {
		switch ((Action) arg) {
		case fetch:
			ref.ref.visit(this, Action.fetch);
			Machine.emit(Op.LOADL, ref.id.decl.entity.fieldDis);
			Machine.emit(Prim.fieldref);
			ref.ixExpr.visit(this, Action.fetch);
			Machine.emit(Prim.arrayref);
			break;
		case assign:
			ref.ref.visit(this, Action.fetch);
			Machine.emit(Op.LOADL, ref.id.decl.entity.fieldDis);
			Machine.emit(Prim.fieldref);
			// need to give the array object address
			ref.ixExpr.visit(this, Action.fetch); // this already gave array Idx
			// want the array address & array Idx
			break;
		}
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/******************************
	 * Visit Terminal
	 ******************************/

	/**************************************************************************/
	/**************************************************************************/
	@Override
	public Object visitIdentifier(Identifier id, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitOperator(Operator op, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitIntLiteral(IntLiteral num, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitBooleanLiteral(BooleanLiteral bool, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object visitNullLiteral(NullLiteral nllLit, Object arg) {
		// TODO Auto-generated method stub
		return null;
	}

	/**************************************************************************/
	/**************************************************************************/
	/**************************
	 * Helper Method
	 ***********************************/

	/**************************************************************************/
	/**************************************************************************/
	public boolean isMain(MethodDecl md) {
		boolean isMain = false;
		// Check method static void with one parameter
		isMain = md.isStatic && md.type.typeKind == TypeKind.VOID && md.parameterDeclList.size() == 1
				&& md.name.equals("main");
		if (isMain) {
			// check the parameter is array
			ParameterDecl pd = md.parameterDeclList.get(0);
			isMain = isMain && pd.type.typeKind == TypeKind.ARRAY;
			if (isMain) {
				// check array's element is class
				ArrayType argType = (ArrayType) pd.type;
				isMain = isMain && argType.eltType.typeKind == TypeKind.CLASS;
				if (isMain) {
					// check class name is 'String'
					isMain = isMain && ((ClassType) argType.eltType).className.spelling.equals("String");
				}
			}
		}
		if (isMain) {
			this.mainCount++;
		}
		return isMain;
	}

}// This is the final bracket for the Generator Class
